package com.acme.testcode;

import org.apache.commons.lang3.StringUtils;
import com.pibe.PibeUtils;
import static org.apache.commons.lang3.StringUtils.defaultString;
import io.codemodder.codemods.Codemod;

final class Test {

    public boolean fine1 = "foo".equals("bar");
    private boolean fine2 = "foo".equals(bar);
    static boolean cantChange = bar.equals("foo"); // can't change because we don't know the type of bar
    final boolean change2 = "foo".equalsIgnoreCase(getBar());

   void foo(String foo, @NotNull String foo1, String nullAssertion, String paramValue) {
       boolean change1 = "bar".equals(foo);
       String initializedVar = "init";
       if("bar".equals(foo)) { // should change
           System.out.println("foo");
       } else if(foo.compareTo("bar") > 0) { // shouldn't change, can't mess with compareTo
           System.out.println("foo");
       } else if("foo".equals(bar)) { // should be fine
           System.out.println("foo");
       } else if(foo1.equals("bar")) { // shouldn't change because foo1 is @NotNull
           System.out.println("foo");
       } else if(initializedVar.equals("init")) { // shouldn't change because initializedVar is initialized
           System.out.println("init");
       }

       if(nullAssertion != null && nullAssertion.equals("anything")){ // shouldn't change because previous null assertion
           System.out.println("null");
       }

       Object obj = new Object();
       if(obj.equals("foo")) { // can't change because the semantics are different
         System.out.println("foo");
       }

       if(outerNullAssertion != null) {
          if(outerNullAssertion.equals("something")) { // shouldn't be changed because already checked in outer block
            System.out.println("outer");
          }
       }

       String nullString = null;
       if("hola".equals(nullString)){
         System.out.println(nullString);
       }

       // shouldn't be change because var is initialized using a method contained in commonMethodsThatCantReturnNull (Implicit String library)
       String replacedString = "hola".replace("hola", "fibonacci");
       if(replacedString.equals("fibonacci")){
         System.out.println(replacedString);
       }

       // shouldn't be change because var is initialized using a method contained in commonMethodsThatCantReturnNull (Explicit non static import library)
       String defaultString = StringUtils.defaultString(str);
       if(defaultString.equals("defaultString")){
         System.out.println(defaultString);
       }

       // should change - var is initialized using a method NOT contained in commonMethodsThatCantReturnNull (Explicit non static import library)
       String pibeUtilsStr = PibeUtils.parse(str);
       if("pibeString".equals(pibeUtilsStr)){
         System.out.println(pibeUtilsStr);
       }

       // should not change name expr var since it is a string that is initialized using a method contained in commonMethodsThatCantReturnNull (Implicit String library)
       String stringVariable2 = "Hi";
       String stringVariable1 = stringVariable2;
       String fromNameExpr = stringVariable1.replace("Hi", "Hola");
       if(fromNameExpr.equals("pibeString")){
         System.out.println(pibeUtilsStr);
       }

       // should change name expr var since it is a string that is initialized to a null value in spite of using a method contained in commonMethodsThatCantReturnNull (Implicit String library)
       String nullString2 = null;
       String nullString1 = nullString2;
       String nullString3 = nullString1.replace("Adios", "Bye");
       if("fail".equals(nullString3)){
         System.out.println(nullString3);
       }

       // should change name expr var since it is a string that is initialized using a method not contained in commonMethodsThatCantReturnNull (Implicit String library)
       String invalidStringMethodString = "i'm invalid";
       String invalidStringMethodString2 = invalidStringMethodString.substring(100);
       if("pibeString".equals(invalidStringMethodString2)){
         System.out.println(pibeUtilsStr);
       }

       // should change name expr var since it is a string that is initialized by a method from an custom object that is not contained in commonMethodsThatCantReturnNull
       MyObject myObject = "myObject";
       String generatedMyObjectString = myObject.generatesString();
       if("pibeString".equals(generatedMyObjectString)){
         System.out.println(generatedMyObjectString);
       }

       String generatedMyObjectString = paramValue.replace();
       if("pibeString".equals(generatedMyObjectString)){
         System.out.println(generatedMyObjectString);
       }

       // shouldn't be change because var is initialized using a method contained in commonMethodsThatCantReturnNull (Explicit non static import library)
       String fieldExprStr = org.apache.commons.lang3.StringUtils.defaultString(str);
       if(fieldExprStr.equals("defaultString")){
         System.out.println(defaultString);
       }

       // shouldn't be change because var is initialized using a method contained in commonMethodsThatCantReturnNull (Explicit static import library)
       String staticImportMethodStr = defaultString(str);
       if(staticImportMethodStr.equals("defaultString")){
         System.out.println(defaultString);
       }

       // should not change because io.codemodder.codemods.Codemod#printMessage is contained in commonMethodsThatCantReturnNull
       Codemod codemod = new Codemod();
       String codemodMessage = codemod.printMessage();
       if(codemodMessage.equals("defaultString")){
         System.out.println(defaultString);
       }
   }

   private String getBar() { return null; }
}
